<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPH Technologies</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- FIXED SVG BACKGROUND STAGE -->
<div class="board-stage" aria-hidden="true">
    <div class="board-camera" id="boardCamera">
        <!-- SVG injected inline here -->
    </div>
    <div class="board-vignette"></div>
</div>

<!-- HEADER -->
<header class="header">
    <div class="container header-inner">
        <div class="logo">EPH Technologies</div>

        <!-- MOBILE MENU BUTTON -->
        <button class="menu-toggle" aria-label="Toggle menu">‚ò∞</button>

        <nav class="nav">
            <a href="#home" data-target="home">Home</a>
            <a href="#about" data-target="about">About</a>
            <a href="#services" data-target="services">Services</a>
            <a href="#portfolio" data-target="portfolio">Portfolio</a>
            <a href="#contact" data-target="contact">Contact</a>
            <a href="#" class="shop-btn">Tech Shop</a>
        </nav>
    </div>
</header>

<!-- HERO -->
<section class="hero" id="home">
    <div class="container hero-inner">
        <h1>Your technology backbone ‚Äî done right.</h1>
        <p>
            Systems, software, hardware, and support ‚Äî built to work together
        </p>

        <div class="hero-actions">
            <a href="#" class="btn primary">Explore Services</a>
            <a href="#" class="btn secondary">Contact Us</a>
        </div>
    </div>
</section>

<!-- SERVICES -->
<section class="services" id="services">
    <div class="container">
        <h2 class="section-title">What we do</h2>

        <div class="services-grid">
            <div class="service-card">
                <h3>Software Systems</h3>
                <p>Custom web, desktop, and automation systems built to scale.</p>
            </div>

            <div class="service-card">
                <h3>Web & App Development</h3>
                <p>Modern, responsive websites and mobile applications.</p>
            </div>

            <div class="service-card">
                <h3>AI & Automation</h3>
                <p>Machine learning, analytics, and intelligent workflows.</p>
            </div>

            <div class="service-card">
                <h3>CCTV Smart Analytics</h3>
                <p>AI-powered surveillance, monitoring, and detection systems.</p>
            </div>

            <div class="service-card">
                <h3>Hardware & Networking</h3>
                <p>PCs, servers, networking, and infrastructure solutions.</p>
            </div>

            <div class="service-card">
                <h3>Support & Maintenance</h3>
                <p>Long-term technical support and system reliability.</p>
            </div>
        </div>
    </div>
</section>

<div class="about-break"></div>

<!-- ABOUT -->
<section class="about" id="about">
    <div class="container about-inner">
        <h2 class="about-title">About EPH Technologies</h2>

        <p class="about-lead">
            EPH Technologies is a full-spectrum technology company.
        </p>

        <p class="about-body">
            We design, build, and support systems that bring software,
            hardware, intelligence, and security together ‚Äî seamlessly.
            From websites and applications to AI systems, automation,
            infrastructure, and smart CCTV analytics, we turn complex
            ideas into reliable, working solutions.
        </p>

        <p class="about-signature">
            We are your 1-Stop Solutions ‚Äî Always Ready.
        </p>
    </div>
</section>

<!-- PORTFOLIO -->
<section class="portfolio" id="portfolio">
    <div class="container">
        <div class="portfolio-header">
            <h2 class="portfolio-title">Selected Work</h2>
            <p class="portfolio-subtitle">
                A snapshot of systems we‚Äôve designed, built, and delivered.
            </p>
        </div>

        <div class="portfolio-grid">
            <div class="portfolio-item">
                <h3>Smart CCTV Analytics</h3>
                <p>
                    AI-powered monitoring, detection, behavior analysis,
                    and real-time alerts for physical security systems.
                </p>
            </div>

            <div class="portfolio-item">
                <h3>Business Management System</h3>
                <p>
                    Custom-built platforms to streamline operations,
                    reporting, automation, and decision-making.
                </p>
            </div>

            <div class="portfolio-item">
                <h3>Web & App Platform</h3>
                <p>
                    Scalable, responsive web and mobile applications
                    engineered for performance and growth.
                </p>
            </div>
        </div>
    </div>
</section>

<!-- CONTACT -->
<section class="contact" id="contact">
    <div class="container contact-inner">
        <div class="contact-left">
            <h2 class="contact-title">Let‚Äôs Build Something That Works</h2>
            <p class="contact-text">
                Whether you need a system, platform, infrastructure, or intelligent solution ‚Äî
                we‚Äôre ready to design and deliver it properly.
            </p>
        </div>

        <div class="contact-right">
            <div class="contact-item">
                <span>Email</span>
                <p>contact@ephtechnologies.com</p>
            </div>

            <div class="contact-item">
                <span>Phone / WhatsApp</span>
                <p>+60 XXX XXXX</p>
            </div>

            <div class="contact-item">
                <span>Location</span>
                <p>Malaysia</p>
            </div>

            <a href="#" class="contact-btn">Start a Conversation</a>
        </div>
    </div>
</section>

<script>
(() => {
  "use strict";

  // ----- CONFIG (unchanged except added TRACE_GROUP) -----
  const CAMERA_WRAP = document.getElementById("boardCamera");
  const SECTION_TO_CPU_STROKE = {
    home: null,
    about:   "#00E5FF",
    services: "#A55AFF",
    portfolio:"#FFB43C",
    contact:  "#00FF8C",
  };
  const SECTION_PAD = { about: 3.1, services: 3.1, portfolio: 3.1, contact: 3.1 };
  const ANIM_MS = 900;
  const OBS_DEBOUNCE_MS = 140;

  // ----- TRACE CONFIG (NEW ‚Äì stroke based) -----
  const TRACE_GROUP_ID = "Trace_Global";        // your exact group ID
  const TRACE_BASE_COLOR = "#282E3B";           // dark grey
  const TRACE_FLOW_COLOR = "rgba(120,200,255,0.65)"; // ice blue (slightly brighter)
  const TRACE_GLOW_COLOR = "rgba(0,229,255,0.18)";
  const TRACE_STROKE_WIDTH = 2;                 // from Figma
  const TRACE_DASH_ARRAY = "8 8";               // dash + gap (adjust for density)
  const TRACE_ANIM_DURATION = 1.2;              // base speed (seconds)

  // ----- STATE -----
  let svgEl = null;
  let originalViewBox = null;
  let activeSection = "home";
  let activeBbox = null;
  let rafId = null;
  let isAnimating = false;
  let traceFlowInstalled = false;   // one‚Äëtime installation

  // ----- UTILS (unchanged) -----
  const parseViewBox = (vbStr) => {
    const parts = (vbStr || "").trim().split(/[\s,]+/).map(Number);
    if (parts.length !== 4 || parts.some(Number.isNaN)) return null;
    return { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
  };
  const formatViewBox = (vb) => `${vb.x} ${vb.y} ${vb.w} ${vb.h}`;
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const easeInOutCubic = (t) => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
  const safeGetBBox = (node) => { try { return node.getBBox(); } catch { return null; } };
  const hexToRgb = (hex) => {
    const h = (hex || "").replace("#","").trim();
    if (h.length !== 6) return null;
    const n = parseInt(h,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  };

  // ----- VIEWBOX ANIMATION (unchanged) -----
  const getCurrentViewBox = () => parseViewBox(svgEl.getAttribute("viewBox")) || originalViewBox;
  const stopAnim = () => { if (rafId) cancelAnimationFrame(rafId); rafId = null; isAnimating = false; };

  const computeTargetViewBoxFromBBox = (bbox, padFactor) => {
    if (!bbox || !originalViewBox) return originalViewBox;
    const viewportAspect = window.innerWidth / Math.max(1, window.innerHeight);
    const cx = bbox.x + bbox.width/2;
    const cy = bbox.y + bbox.height/2;
    let targetW = bbox.width * padFactor;
    let targetH = bbox.height * padFactor;
    const targetAspect = targetW / Math.max(1e-6, targetH);
    if (targetAspect > viewportAspect) targetH = targetW / viewportAspect;
    else targetW = targetH * viewportAspect;
    let x = cx - targetW/2;
    let y = cy - targetH/2;
    const ovb = originalViewBox;
    const maxX = ovb.x + ovb.w - targetW;
    const maxY = ovb.y + ovb.h - targetH;
    x = clamp(x, ovb.x, maxX);
    y = clamp(y, ovb.y, maxY);
    return { x, y, w: targetW, h: targetH };
  };

  const animateViewBoxTo = (targetVB, durationMs = ANIM_MS) => {
    if (!svgEl || !targetVB) return;
    const startVB = getCurrentViewBox();
    const startTime = performance.now();
    stopAnim();
    isAnimating = true;
    const tick = (now) => {
      const tRaw = (now - startTime) / Math.max(1, durationMs);
      const t = clamp(tRaw, 0, 1);
      const e = easeInOutCubic(t);
      const vb = {
        x: startVB.x + (targetVB.x - startVB.x) * e,
        y: startVB.y + (targetVB.y - startVB.y) * e,
        w: startVB.w + (targetVB.w - startVB.w) * e,
        h: startVB.h + (targetVB.h - startVB.h) * e,
      };
      svgEl.setAttribute("viewBox", formatViewBox(vb));
      if (t < 1) rafId = requestAnimationFrame(tick);
      else { isAnimating = false; rafId = null; }
    };
    rafId = requestAnimationFrame(tick);
  };

  // ----- CPU DETECTION & GLOW (unchanged) -----
  const findCpuByStroke = (strokeHex) => {
    if (!svgEl || !strokeHex) return null;
    let el = svgEl.querySelector(`[stroke="${strokeHex}"]`);
    if (el) return el;
    const all = Array.from(svgEl.querySelectorAll("[stroke]"));
    return all.find(n => (n.getAttribute("stroke") || "").toLowerCase() === strokeHex.toLowerCase()) || null;
  };

  const setCpuGlowActive = (node, strokeHex) => {
    if (!svgEl) return;
    svgEl.querySelectorAll(".cpu-active").forEach(n => n.classList.remove("cpu-active"));
    if (node) node.classList.add("cpu-active");
    if (strokeHex) {
      const rgb = hexToRgb(strokeHex);
      if (rgb) svgEl.style.setProperty("--cpuGlow", `${rgb.r}, ${rgb.g}, ${rgb.b}`);
    }
  };

  // ----- SECTION ACTIVATION (unchanged) -----
  const activateSection = (sectionId) => {
    if (!svgEl || !originalViewBox || !sectionId) return;
    if (sectionId === activeSection && !isAnimating) return;
    activeSection = sectionId;

    if (sectionId === "home") {
      activeBbox = null;
      setCpuGlowActive(null, null);
      animateViewBoxTo({ ...originalViewBox });
      return;
    }

    const strokeHex = SECTION_TO_CPU_STROKE[sectionId];
    const cpuNode = findCpuByStroke(strokeHex);
    if (!cpuNode) {
      console.warn(`[BOARD] CPU not found for "${sectionId}" ‚Äì check stroke colors`);
      setCpuGlowActive(null, null);
      animateViewBoxTo({ ...originalViewBox });
      return;
    }

    const bbox = safeGetBBox(cpuNode);
    if (!bbox) {
      console.warn(`[BOARD] getBBox failed for "${sectionId}"`);
      setCpuGlowActive(null, null);
      animateViewBoxTo({ ...originalViewBox });
      return;
    }

    activeBbox = bbox;
    setCpuGlowActive(cpuNode, strokeHex);
    const pad = SECTION_PAD[sectionId] ?? 3.1;
    const targetVB = computeTargetViewBoxFromBBox(bbox, pad);
    animateViewBoxTo(targetVB);
  };

  const debounce = (fn, wait) => {
    let t = null;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
  };
  const activateSectionDebounced = debounce(activateSection, OBS_DEBOUNCE_MS);

  // ----- INTERSECTION OBSERVER (unchanged) -----
  const setupObserver = () => {
    const ids = Object.keys(SECTION_TO_CPU_STROKE);
    const sections = ids.map(id => document.getElementById(id)).filter(Boolean);
    if (!sections.length) {
      console.warn("[BOARD] Sections not found ‚Äì need ids: home/about/services/portfolio/contact");
      return;
    }
    const io = new IntersectionObserver((entries) => {
      const visible = entries
        .filter(e => e.isIntersecting)
        .sort((a,b) => b.intersectionRatio - a.intersectionRatio);
      if (visible.length) activateSectionDebounced(visible[0].target.id);
    }, { threshold: [0.35, 0.5, 0.65], rootMargin: "-18% 0px -18% 0px" });
    sections.forEach(s => io.observe(s));
  };

  // ----- RESIZE HANDLER (unchanged) -----
  const setupResizeHandler = () => {
    let t = null;
    window.addEventListener("resize", () => {
      clearTimeout(t);
      t = setTimeout(() => {
        if (!svgEl || !originalViewBox) return;
        if (activeSection === "home" || !activeBbox) {
          svgEl.setAttribute("viewBox", formatViewBox(originalViewBox));
          return;
        }
        const pad = SECTION_PAD[activeSection] ?? 3.1;
        const vb = computeTargetViewBoxFromBBox(activeBbox, pad);
        svgEl.setAttribute("viewBox", formatViewBox(vb));
      }, 90);
    }, { passive: true });
  };

  // ========== üêç NEW ‚Äì STROKE‚ÄëBASED ‚ÄúELECTRIC WORMS‚Äù ==========
  // Finds #Trace_Global, ensures strokes, clones for moving highlight.
  const installTraceFlow = () => {
    if (traceFlowInstalled || !svgEl) return;
    traceFlowInstalled = true;

    // 1. Locate the trace group
    let traceGroup = svgEl.querySelector(`#${TRACE_GROUP_ID}`);
    if (!traceGroup) {
      // Fallback: try to find any group containing paths with stroke="#282E3B"
      console.warn(`[TRACE] Group #${TRACE_GROUP_ID} not found ‚Äì falling back to search by stroke color.`);
      const possiblePaths = Array.from(svgEl.querySelectorAll(`path[stroke="${TRACE_BASE_COLOR}"]`));
      if (possiblePaths.length) {
        // wrap them in a temporary group
        traceGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        traceGroup.id = "Trace_Global_fallback";
        possiblePaths.forEach(p => traceGroup.appendChild(p.cloneNode(true)));
        svgEl.appendChild(traceGroup);
      } else {
        console.error("[TRACE] No trace paths found ‚Äì aborting flow effect.");
        return;
      }
    }

    // 2. Get all <path> elements inside the group
    const tracePaths = Array.from(traceGroup.querySelectorAll("path"));
    if (!tracePaths.length) {
      console.error("[TRACE] No <path> elements inside trace group.");
      return;
    }

    // 3. Ensure base paths have correct appearance
    tracePaths.forEach(path => {
      path.setAttribute("stroke", TRACE_BASE_COLOR);
      path.setAttribute("stroke-width", TRACE_STROKE_WIDTH);
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-linecap", "round");
      path.setAttribute("stroke-linejoin", "round");
      path.classList.add("trace-base");   // optional, for styling
    });

    // 4. Create a new group for the animated flow overlays
    const flowGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    flowGroup.id = "Trace_Flow";
    flowGroup.classList.add("trace-flow-group");

    // 5. Clone each path, style with flow color, dasharray, animation
    tracePaths.forEach((original, index) => {
      const clone = original.cloneNode(false); // false = don't clone children (none)
      
      // Copy all attributes from original (d, transform, etc.)
      const attrs = original.attributes;
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.name === "class") continue; // we'll set our own
        clone.setAttribute(attr.name, attr.value);
      }

      // Apply flow styling
      clone.setAttribute("stroke", TRACE_FLOW_COLOR);
      clone.setAttribute("stroke-width", TRACE_STROKE_WIDTH);
      clone.setAttribute("fill", "none");
      clone.setAttribute("stroke-linecap", "round");
      clone.setAttribute("stroke-linejoin", "round");
      clone.setAttribute("stroke-dasharray", TRACE_DASH_ARRAY);
      
      // Add animation via CSS class ‚Äì we'll define .trace-flow in CSS
      clone.classList.add("trace-flow");

      // ----- Variation: random delay & duration (subtle difference) -----
      const delay = (index * 0.2) % 1.2;         // staggered start
      const duration = TRACE_ANIM_DURATION + (index % 3) * 0.2; // 1.2 / 1.4 / 1.6
      clone.style.animationDelay = `${delay}s`;
      clone.style.animationDuration = `${duration}s`;

      flowGroup.appendChild(clone);
    });

    // 6. Insert flow group right after the original trace group (so it draws on top)
    traceGroup.parentNode.insertBefore(flowGroup, traceGroup.nextSibling);

    console.log(`[TRACE] Installed stroke‚Äëbased flow on ${tracePaths.length} traces.`);
  };

  // ----- SVG LOADER (unchanged ‚Äì just calls new installTraceFlow) -----
  const loadSvg = async () => {
    try {
      const res = await fetch("BOARD-BASE.svg", { cache: "no-store" });
      const txt = await res.text();
      CAMERA_WRAP.innerHTML = txt;

      svgEl = CAMERA_WRAP.querySelector("svg");
      if (!svgEl) throw new Error("SVG element not found");

      svgEl.style.width = "100%";
      svgEl.style.height = "100%";
      svgEl.style.display = "block";
      svgEl.setAttribute("preserveAspectRatio", "xMidYMid meet");

      const vb = parseViewBox(svgEl.getAttribute("viewBox"));
      originalViewBox = vb || { x:0, y:0, w:1440, h:1024 };
      svgEl.setAttribute("viewBox", formatViewBox(originalViewBox));

      installTraceFlow();      // üêç STROKE‚ÄëBASED FLOW
      setupObserver();
      setupResizeHandler();
      activateSection("home");
    } catch (err) {
      console.error("[BOARD] Failed to load SVG:", err);
    }
  };

  // ----- START -----
  if (CAMERA_WRAP) loadSvg();
  else console.error("[BOARD] #boardCamera element not found");
})();
</script>


</body>
</html>
